import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.plugins.ide.eclipse.model.*

eclipse.classpath {
	downloadJavadoc true
	downloadSources true
}

eclipse.classpath.file.whenMerged { cp ->
	tasks.withType JavaCompile, { JavaCompile jc ->
		final File out = jc.destinationDirectory.asFile.get()

		if( !file("src/${out.name}/java").exists() ) {
			return
		}

		final File gen = jc.options.generatedSourceOutputDirectory.get().asFile

		logger.info("Creating " + rootProject.relativePath(gen) )

		gen.mkdirs()

		final String src = relativePath( gen )

		if( cp.entries.find { ent -> ent.path == src } ) {
			return
		}

		final String dst = relativePath( out ).replace('build', 'bin')
		final ClasspathEntry ent = new SourceFolder( src, dst )

		ent.entryAttributes['gradle_scope'] = out.name

		cp.entries << ent
	}

	cp.entries
			.findAll { ent -> ent instanceof SourceFolder }
			.each { SourceFolder ent ->
				def scope = ent.entryAttributes['gradle_scope']

				ent.entryAttributes['test'] = scope != 'main'

				switch( scope ) {
					case 'main':
						ent.entryAttributes['gradle_used_by_scope'] = 'main,test,testFixtures'
						break
					case 'testFixtures':
						ent.entryAttributes['gradle_used_by_scope'] = 'test,testFixtures'
						break
					case 'test':
						ent.entryAttributes['gradle_used_by_scope'] = 'test'
						break
				}
			}

	// https://github.com/eclipse/buildship/issues/1206
	cp.entries
			.findAll { ent -> ent instanceof ProjectDependency }
			.findAll { ent -> ent.entryAttributes.test }
			.each { ent -> ent.entryAttributes['test'] = 'false' }
}
